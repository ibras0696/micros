# Sprint 1 — Auth

Цель: рабочий auth-сервис с регистрацией/логином/refresh/me, хранением refresh-токенов и их ротацией, Alembic-миграциями, JWT RS256, и тестами (pytest + httpx.AsyncClient) с покрытием ядра ≥ 80%.

Ниже — **полный каркас файлов**, готовые фрагменты кода и команды.

---

## 0) Зависимости и переменные окружения

**`auth-svc/pyproject.toml`** (обновлённая версия)

```toml
[build-system]
requires = ["setuptools>=68", "wheel"]
build-backend = "setuptools.build_meta"

[project]
name = "auth_svc"
version = "0.1.0"
description = "Auth microservice (FastAPI + SQLAlchemy + Alembic + JWT RS256)"
requires-python = ">=3.12"
dependencies = [
  "fastapi>=0.115",
  "uvicorn[standard]>=0.30",
  "pydantic>=2.8",
  "sqlalchemy>=2.0",
  "alembic>=1.13",
  "aiosqlite>=0.20",         # для тестов по умолчанию (sqlite)
  "psycopg[binary]>=3.2",     # для Postgres в проде (опционально)
  "passlib[bcrypt]>=1.7",
  "python-jose[cryptography]>=3.3",
  "prometheus-fastapi-instrumentator>=7.0",
  "httpx>=0.27",
]

[project.optional-dependencies]
dev = [
  "pytest>=8.2",
  "pytest-asyncio>=0.23",
  "pytest-cov>=5.0",
  "anyio>=4.4",
]

[tool.setuptools]
packages = ["app"]

[tool.pytest.ini_options]
addopts = "-q --cov=app --cov-report=term-missing:skip-covered"
asyncio_mode = "auto"
```

**`auth-svc/.env.example`**

```dotenv
# База данных (по умолчанию — sqlite файл в контейнере)
DATABASE_URL=sqlite+aiosqlite:///./auth.db

# Пути к RSA-ключам (см. ниже раздел 5)
JWT_PRIVATE_KEY_PATH=/run/secrets/jwt_private.pem
JWT_PUBLIC_KEY_PATH=/run/secrets/jwt_public.pem

# TTL токенов (в секундах)
ACCESS_TTL=900        # 15 минут
REFRESH_TTL=2592000   # 30 дней

# Идентификатор издателя (в payload)
JWT_ISS=taskhub-auth
```

---

## 1) Модели и слой данных

**Стратегия хранения refresh:**

* Генерируем `jti` (UUID4) и сохраняем запись в таблицу `refresh_tokens` с `user_id`, `expires_at`, `revoked=false`.
* При `POST /auth/refresh` помечаем текущий refresh `revoked=true` и создаём новый (`rotation`).
* Если приходит уже «ревокнутый» `jti`, отклоняем (защита от повторного использования).

> Используем **строковый UUID** (String(36)) для совместимости с SQLite и Postgres без диалект-специфики.

**`auth-svc/app/db.py`**

```python
from __future__ import annotations
from sqlalchemy.ext.asyncio import AsyncEngine, AsyncSession, create_async_engine, async_sessionmaker
from sqlalchemy.orm import DeclarativeBase
from app.settings import settings

class Base(DeclarativeBase):
    pass

engine: AsyncEngine = create_async_engine(settings.DATABASE_URL, echo=False, future=True)
SessionLocal = async_sessionmaker(bind=engine, expire_on_commit=False, class_=AsyncSession)

async def get_session() -> AsyncSession:
    async with SessionLocal() as session:
        yield session
```

**`auth-svc/app/models.py`**

```python
from __future__ import annotations
from datetime import datetime
from typing import Optional
from sqlalchemy import String, Boolean, DateTime, ForeignKey
from sqlalchemy.orm import Mapped, mapped_column, relationship
from app.db import Base

# Удобная фабрика времени
from datetime import timezone

def utcnow() -> datetime:
    return datetime.now(tz=timezone.utc)

class User(Base):
    __tablename__ = "users"

    id: Mapped[str] = mapped_column(String(36), primary_key=True)
    email: Mapped[str] = mapped_column(String(255), unique=True, index=True)
    password_hash: Mapped[str] = mapped_column(String(255))
    created_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), default=utcnow, nullable=False)

    tokens: Mapped[list[RefreshToken]] = relationship(back_populates="user", cascade="all, delete-orphan")

class RefreshToken(Base):
    __tablename__ = "refresh_tokens"

    jti: Mapped[str] = mapped_column(String(36), primary_key=True)
    user_id: Mapped[str] = mapped_column(String(36), ForeignKey("users.id", ondelete="CASCADE"), index=True)
    issued_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), default=utcnow, nullable=False)
    expires_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), nullable=False)
    revoked: Mapped[bool] = mapped_column(Boolean, default=False, nullable=False)
    replaced_by: Mapped[Optional[str]] = mapped_column(String(36), nullable=True)

    user: Mapped[User] = relationship(back_populates="tokens")
```

---

## 2) Alembic: настройка и миграции

**Файлы Alembic** (в каталоге `auth-svc`):

```
auth-svc/
 ├─ alembic.ini
 └─ alembic/
     ├─ env.py
     └─ versions/
```

**`auth-svc/alembic.ini`** (минимально необходимое)

```ini
[alembic]
script_location = alembic
sqlalchemy.url = sqlite+aiosqlite:///./auth.db

[loggers]
keys = root,sqlalchemy,alembic

[handlers]
keys = console

[formatters]
keys = generic

[logger_root]
level = WARN
handlers = console

[logger_sqlalchemy]
level = WARN
handlers =
qualname = sqlalchemy.engine

[logger_alembic]
level = INFO
handlers =
qualname = alembic

[handler_console]
class = StreamHandler
args = (sys.stderr,)
level = NOTSET
formatter = generic

[formatter_generic]
format = %(levelname)-5.5s [%(name)s] %(message)s
```

**`auth-svc/alembic/env.py`** (async-поддержка SA 2.0)

```python
from __future__ import annotations
import asyncio
from logging.config import fileConfig
from sqlalchemy import pool
from sqlalchemy.engine import Connection
from sqlalchemy.ext.asyncio import AsyncEngine, create_async_engine
from alembic import context

from app.db import Base
from app import models  # noqa: F401 — важно для автогенерации таблиц
from app.settings import settings

config = context.config
if config.config_file_name is not None:
    fileConfig(config.config_file_name)

target_metadata = Base.metadata

async def run_migrations_online() -> None:
    connectable: AsyncEngine = create_async_engine(settings.DATABASE_URL, poolclass=pool.NullPool)
    async with connectable.connect() as connection:
        await connection.run_sync(do_run_migrations)
    await connectable.dispose()

def do_run_migrations(connection: Connection) -> None:
    context.configure(connection=connection, target_metadata=target_metadata, compare_type=True)
    with context.begin_transaction():
        context.run_migrations()

def run_migrations_offline() -> None:
    context.configure(url=settings.DATABASE_URL, target_metadata=target_metadata, literal_binds=True, compare_type=True)
    with context.begin_transaction():
        context.run_migrations()

if context.is_offline_mode():
    run_migrations_offline()
else:
    asyncio.run(run_migrations_online())
```

**Команды Alembic:**

```bash
# из каталога auth-svc
alembic revision -m "init users and refresh tokens" --autogenerate
alembic upgrade head
```

> После внесения правок в модели повторяй: `revision --autogenerate` → `upgrade head`.

---

## 3) Настройки, схемы, безопасность

**`auth-svc/app/settings.py`**

```python
from __future__ import annotations
from pydantic import BaseModel
import os

class Settings(BaseModel):
    DATABASE_URL: str = os.getenv("DATABASE_URL", "sqlite+aiosqlite:///./auth.db")

    JWT_PRIVATE_KEY_PATH: str = os.getenv("JWT_PRIVATE_KEY_PATH", "./jwt_private.pem")
    JWT_PUBLIC_KEY_PATH: str = os.getenv("JWT_PUBLIC_KEY_PATH", "./jwt_public.pem")
    ACCESS_TTL: int = int(os.getenv("ACCESS_TTL", "900"))
    REFRESH_TTL: int = int(os.getenv("REFRESH_TTL", "2592000"))
    JWT_ISS: str = os.getenv("JWT_ISS", "taskhub-auth")

settings = Settings()
```

**`auth-svc/app/schemas.py`**

```python
from __future__ import annotations
from pydantic import BaseModel, EmailStr

# Входные/выходные схемы
class RegisterIn(BaseModel):
    email: EmailStr
    password: str

class LoginIn(BaseModel):
    email: EmailStr
    password: str

class TokenPairOut(BaseModel):
    access_token: str
    refresh_token: str
    token_type: str = "bearer"

class MeOut(BaseModel):
    id: str
    email: EmailStr
```

**`auth-svc/app/security.py`**

```python
from __future__ import annotations
from datetime import datetime, timedelta, timezone
from pathlib import Path
from typing import Any
import uuid
from jose import jwt
from passlib.context import CryptContext
from app.settings import settings

pwd_ctx = CryptContext(schemes=["bcrypt"], deprecated="auto")

# Загрузка ключей (PEM)
PRIVATE_KEY = Path(settings.JWT_PRIVATE_KEY_PATH).read_text()
PUBLIC_KEY = Path(settings.JWT_PUBLIC_KEY_PATH).read_text()
ALGO = "RS256"

# Пароли

def hash_password(plain: str) -> str:
    return pwd_ctx.hash(plain)

def verify_password(plain: str, hashed: str) -> bool:
    return pwd_ctx.verify(plain, hashed)

# JWT Access/Refresh

def _now() -> datetime:
    return datetime.now(tz=timezone.utc)

def make_access_token(sub: str) -> str:
    exp = _now() + timedelta(seconds=settings.ACCESS_TTL)
    payload: dict[str, Any] = {"sub": sub, "iss": settings.JWT_ISS, "exp": exp}
    return jwt.encode(payload, PRIVATE_KEY, algorithm=ALGO)

def make_refresh_token(sub: str, jti: str) -> str:
    exp = _now() + timedelta(seconds=settings.REFRESH_TTL)
    payload: dict[str, Any] = {"sub": sub, "iss": settings.JWT_ISS, "exp": exp, "jti": jti}
    return jwt.encode(payload, PRIVATE_KEY, algorithm=ALGO)

def verify_access(token: str) -> dict[str, Any]:
    return jwt.decode(token, PUBLIC_KEY, algorithms=[ALGO], options={"verify_aud": False})

def verify_refresh(token: str) -> dict[str, Any]:
    return jwt.decode(token, PUBLIC_KEY, algorithms=[ALGO], options={"verify_aud": False})


def new_jti() -> str:
    return str(uuid.uuid4())
```

**`auth-svc/app/deps.py`**

```python
from __future__ import annotations
from fastapi import Depends, HTTPException, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from app.db import get_session
from app.models import User
from app.security import verify_access

bearer = HTTPBearer(auto_error=True)

async def get_current_user(
    creds: HTTPAuthorizationCredentials = Depends(bearer),
    session: AsyncSession = Depends(get_session),
) -> User:
    try:
        payload = verify_access(creds.credentials)
        sub = payload.get("sub")
    except Exception:  # noqa: BLE001
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="invalid token")

    if not sub:
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="invalid token")

    user = (await session.execute(select(User).where(User.id == sub))).scalar_one_or_none()
    if not user:
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="user not found")
    return user
```

---

## 4) Роуты: регистрация, логин, refresh, me

**`auth-svc/app/routers/auth.py`**

```python
from __future__ import annotations
from datetime import timedelta
from typing import Annotated
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, update
from app.db import get_session
from app.models import User, RefreshToken
from app.schemas import RegisterIn, LoginIn, TokenPairOut, MeOut
from app.security import hash_password, verify_password, make_access_token, make_refresh_token, new_jti
from app.deps import get_current_user
from app.settings import settings

import uuid
from datetime import datetime, timezone

def utcnow() -> datetime:
    return datetime.now(tz=timezone.utc)

router = APIRouter(prefix="/auth", tags=["auth"])

@router.post("/register", status_code=201)
async def register(data: RegisterIn, session: Annotated[AsyncSession, Depends(get_session)]) -> TokenPairOut:
    # 1) проверить email уникальность
    exists = (await session.execute(select(User).where(User.email == data.email))).scalar_one_or_none()
    if exists:
        raise HTTPException(status_code=400, detail="email already registered")

    user = User(id=str(uuid.uuid4()), email=data.email, password_hash=hash_password(data.password))
    session.add(user)
    await session.flush()

    # создать refresh запись + выдать пару токенов
    jti = new_jti()
    rt = RefreshToken(
        jti=jti,
        user_id=user.id,
        issued_at=utcnow(),
        expires_at=utcnow() + timedelta(seconds=settings.REFRESH_TTL),
        revoked=False,
    )
    session.add(rt)

    await session.commit()

    return TokenPairOut(
        access_token=make_access_token(user.id),
        refresh_token=make_refresh_token(user.id, jti),
    )

@router.post("/login")
async def login(data: LoginIn, session: Annotated[AsyncSession, Depends(get_session)]) -> TokenPairOut:
    user = (await session.execute(select(User).where(User.email == data.email))).scalar_one_or_none()
    if not user or not verify_password(data.password, user.password_hash):
        raise HTTPException(status_code=401, detail="invalid credentials")

    jti = new_jti()
    rt = RefreshToken(
        jti=jti,
        user_id=user.id,
        issued_at=utcnow(),
        expires_at=utcnow() + timedelta(seconds=settings.REFRESH_TTL),
        revoked=False,
    )
    session.add(rt)
    await session.commit()

    return TokenPairOut(
        access_token=make_access_token(user.id),
        refresh_token=make_refresh_token(user.id, jti),
    )

@router.post("/refresh")
async def refresh(refresh_token: str, session: Annotated[AsyncSession, Depends(get_session)]) -> TokenPairOut:
    # в простом варианте refresh_token приходит как простой body-строка
    from app.security import verify_refresh
    try:
        payload = verify_refresh(refresh_token)
        sub = payload.get("sub")
        jti = payload.get("jti")
        exp = payload.get("exp")
    except Exception:  # noqa: BLE001
        raise HTTPException(status_code=401, detail="invalid refresh token")

    if not sub or not jti:
        raise HTTPException(status_code=401, detail="invalid refresh token")

    # проверить, что rt не отозван и не истёк в БД
    rt = (await session.execute(select(RefreshToken).where(RefreshToken.jti == jti))).scalar_one_or_none()
    if not rt or rt.revoked or rt.expires_at < utcnow():
        raise HTTPException(status_code=401, detail="refresh token revoked or expired")

    # ротация: пометить текущий revoked и выпустить новый
    new_j = new_jti()
    await session.execute(
        update(RefreshToken)
        .where(RefreshToken.jti == jti)
        .values(revoked=True, replaced_by=new_j)
    )

    new_rt = RefreshToken(
        jti=new_j,
        user_id=rt.user_id,
        issued_at=utcnow(),
        expires_at=utcnow() + timedelta(seconds=settings.REFRESH_TTL),
        revoked=False,
    )
    session.add(new_rt)
    await session.commit()

    return TokenPairOut(
        access_token=make_access_token(rt.user_id),
        refresh_token=make_refresh_token(rt.user_id, new_j),
    )

@router.get("/me", response_model=MeOut)
async def me(user: Annotated[User, Depends(get_current_user)]) -> MeOut:
    return MeOut(id=user.id, email=user.email)
```

**`auth-svc/app/main.py`**

```python
from __future__ import annotations
from fastapi import FastAPI
from prometheus_fastapi_instrumentator import Instrumentator
from app.routers import auth

app = FastAPI(title="Auth Service")
app.include_router(auth.router)

@app.get("/healthz")
def healthz() -> dict[str, str]:
    return {"status": "ok"}

Instrumentator().instrument(app).expose(app)
```

---

## 5) RSA‑ключи для RS256

Сгенерируй ключи и передай их в контейнер (например, через Docker secrets или монтированием тома):

```bash
# локально (в каталоге auth-svc)
openssl genrsa -out jwt_private.pem 2048
openssl rsa -in jwt_private.pem -pubout -out jwt_public.pem
```

В Compose можно добавить к сервису `auth-svc`:

```yaml
  auth-svc:
    build: ../auth-svc
    environment:
      - PYTHONUNBUFFERED=1
    secrets:
      - jwt_private.pem
      - jwt_public.pem
    networks: [private]

secrets:
  jwt_private.pem:
    file: ../auth-svc/jwt_private.pem
  jwt_public.pem:
    file: ../auth-svc/jwt_public.pem
```

И в `.env` оставить пути `/run/secrets/...` (как в примере выше).

---

## 6) Тесты (pytest + httpx.AsyncClient)

Структура:

```
auth-svc/
 └─ tests/
     ├─ conftest.py
     └─ test_auth_flow.py
```

**`auth-svc/tests/conftest.py`**

```python
from __future__ import annotations
import asyncio
import os
import pytest
from httpx import AsyncClient
from sqlalchemy.ext.asyncio import AsyncEngine
from sqlalchemy.ext.asyncio import create_async_engine
from sqlalchemy.orm import sessionmaker
from sqlalchemy.ext.asyncio import AsyncSession

# Настроим тестовую БД (sqlite в файл/памяти)
os.environ.setdefault("DATABASE_URL", "sqlite+aiosqlite:///./test.db")
os.environ.setdefault("ACCESS_TTL", "60")      # короче, чтобы быстрее тестировать
os.environ.setdefault("REFRESH_TTL", "3600")

# Упростим ключи для тестов (генерируй заранее или подставь строки)
from pathlib import Path

TEST_PRIV = """-----BEGIN RSA PRIVATE KEY-----
MIIBOgIBAAJBALgA4...FAKE...==
-----END RSA PRIVATE KEY-----
""".strip()
TEST_PUB = """-----BEGIN PUBLIC KEY-----
MFwwDQYJ...FAKE...==
-----END PUBLIC KEY-----
""".strip()

Path("jwt_private.pem").write_text(TEST_PRIV)
Path("jwt_public.pem").write_text(TEST_PUB)

os.environ.setdefault("JWT_PRIVATE_KEY_PATH", "./jwt_private.pem")
os.environ.setdefault("JWT_PUBLIC_KEY_PATH", "./jwt_public.pem")

import app.main  # noqa: E402
from app.db import Base, engine, SessionLocal  # noqa: E402

@pytest.fixture(scope="session")
def event_loop():
    loop = asyncio.get_event_loop()
    yield loop

@pytest.fixture(autouse=True, scope="session")
async def prepare_db():
    # создаём таблицы
    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.create_all)
    yield
    # дропаем таблицы
    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.drop_all)

@pytest.fixture()
async def client():
    async with AsyncClient(app=app.main.app, base_url="http://testserver") as ac:
        yield ac
```

> ⚠️ Для реальных тестов подставь **настоящие** RSA-ключи (или генерацию перед запуском) — здесь сокращено (FAKE) ради компактности.

**`auth-svc/tests/test_auth_flow.py`**

```python
import pytest
from httpx import AsyncClient

@pytest.mark.anyio
async def test_register_login_me_refresh(client: AsyncClient):
    # регистрация
    r = await client.post("/auth/register", json={"email": "u@example.com", "password": "secret123"})
    assert r.status_code == 201, r.text
    data = r.json()
    assert "access_token" in data and "refresh_token" in data

    # доступ к /auth/me с access
    headers = {"Authorization": f"Bearer {data['access_token']}"}
    me = await client.get("/auth/me", headers=headers)
    assert me.status_code == 200
    assert me.json()["email"] == "u@example.com"

    # логин (вторая пара токенов)
    r2 = await client.post("/auth/login", json={"email": "u@example.com", "password": "secret123"})
    assert r2.status_code == 200
    d2 = r2.json()
    assert d2["access_token"] and d2["refresh_token"]

    # refresh (ротация)
    r3 = await client.post("/auth/refresh", json="" + d2["refresh_token"] + "")
    assert r3.status_code == 200
    d3 = r3.json()
    assert d3["access_token"] and d3["refresh_token"]

    # старый refresh больше невалиден
    r4 = await client.post("/auth/refresh", json="" + d2["refresh_token"] + "")
    assert r4.status_code == 401
```

Запуск тестов и покрытие:

```bash
# из каталога auth-svc
pytest -q --cov=app --cov-report=term-missing
```

> Добейся ≥ 80% покрытия по `app/*` — при текущем каркасе это достижимо.

---

## 7) Makefile цели (удобно для спринта)

**`auth-svc/Makefile`** (локальный в сервисе — доп. к корневому)

```makefile
.PHONY: venv deps migrate revision test cov

venv:
	python -m venv .venv && . .venv/bin/activate && pip -V

deps:
	pip install -U pip && pip install .[dev]

revision:
	alembic revision -m "auto" --autogenerate

migrate:
	alembic upgrade head

test:
	pytest -q

cov:
	pytest -q --cov=app --cov-report=term-missing
```

---

## 8) Критерии готовности (Definition of Done)

* [ ] Миграции Alembic создают таблицы `users` и `refresh_tokens`.
* [ ] POST `/auth/register` создаёт пользователя и возвращает пару токенов.
* [ ] POST `/auth/login` возвращает пару токенов для существующего пользователя.
* [ ] POST `/auth/refresh` делает ротацию (старый `jti` → `revoked=true`, создаёт новый токен и запись).
* [ ] GET `/auth/me` возвращает текущего пользователя по access JWT.
* [ ] Все тесты зелёные (`pytest`).
* [ ] Покрытие `app/*` ≥ 80% (`pytest --cov`).
* [ ] Метрики `/metrics` и `/healthz` работают (интегрируются с Prometheus).

---

## 9) Подсказки и частые ошибки

* **SQLite vs Postgres**: в проде используй Postgres; для тестов оставь SQLite (поэтому ID как `String(36)`).
* **RS256 ключи**: проверь, что пути совпадают с `.env` и контейнер их видит. Ошибка `InvalidSignatureError` — обычно не тот ключ/формат.
* **Ротация**: обязательно помечай старый refresh `revoked=true` и `replaced_by=<new_jti>` до коммита новой записи.
* **Пароли**: никогда не храни «в чистом виде», только `bcrypt` хэш.
* **Типы времени**: всегда `timezone-aware` (`timezone.utc`).

---

Готово. Если хочешь — добавлю в этот спринт: rate limiting для `/login`, blacklisting украденных refresh’ей (по `jti`), и e2e-тест в Compose с Postgres и реальным RSA.

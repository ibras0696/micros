# taskhub — микросервисный каркас (FastAPI + Nginx Gateway + Prometheus + Grafana)

Готовый шаблон под выданные задачи. Копируй файлы как есть. Ниже: структура, содержимое каждого файла и команды запуска.

---

## 1) Структура репозитория

```
taskhub/
├── .editorconfig
├── Makefile
├── tooling/
│   ├── ruff.toml
│   └── mypy.ini
├── gateway/
│   ├── Dockerfile
│   └── nginx.conf
├── auth-svc/
│   ├── pyproject.toml
│   ├── Dockerfile
│   ├── .env.example
│   └── app/
│       └── main.py
├── task-svc/
│   ├── pyproject.toml
│   ├── Dockerfile
│   ├── .env.example
│   └── app/
│       └── main.py
├── notify-svc/
│   ├── pyproject.toml
│   ├── Dockerfile
│   ├── .env.example
│   └── app/
│       └── main.py
└── infra/
    ├── docker-compose.yml
    ├── prometheus/
    │   └── prometheus.yml
    └── grafana/
        └── provisioning/
            └── datasources/
                └── datasource.yml
```

---

## 2) Корневые файлы

### `.editorconfig`

```ini
root = true

[*]
charset = utf-8
indent_style = space
indent_size = 4
end_of_line = lf
insert_final_newline = true
trim_trailing_whitespace = true
```

### `Makefile`

```makefile
.PHONY: up down logs ps lint typecheck fmt build

up:
	cd infra && docker compose up -d --build

down:
	cd infra && docker compose down -v

logs:
	cd infra && docker compose logs -f --tail=200

ps:
	cd infra && docker compose ps

lint:
	ruff check auth-svc task-svc notify-svc

typecheck:
	mypy auth-svc task-svc notify-svc

fmt:
	ruff format auth-svc task-svc notify-svc

build:
	cd infra && docker compose build
```

### `tooling/ruff.toml`

```toml
line-length = 100
select = ["E", "F", "I", "B", "UP"]
ignore = ["E501"]
```

### `tooling/mypy.ini`

```ini
[mypy]
python_version = 3.12
disallow_untyped_defs = True
warn_unused_ignores = True
warn_redundant_casts = True
no_implicit_optional = True
strict_optional = True
```

---

## 3) Gateway (Nginx)

### `gateway/Dockerfile`

```dockerfile
FROM nginx:1.27-alpine
COPY nginx.conf /etc/nginx/nginx.conf
```

### `gateway/nginx.conf`

```nginx
events {}
http {
    server {
        listen 80;

        # Healthcheck самого шлюза
        location = /healthz {
            return 200 'ok';
            add_header Content-Type text/plain;
        }

        # Проксирование на сервисы
        location /auth/ {
            proxy_pass http://auth-svc:8001/;
        }

        location /tasks/ {
            proxy_pass http://task-svc:8002/;
        }

        location /notify/ {
            proxy_pass http://notify-svc:8003/;
        }
    }
}
```

---

## 4) Мини‑сервисы FastAPI

Все три сервиса идентичны по каркасу. Ниже показан пример для `auth-svc`; для `task-svc` и `notify-svc` меняется только имя/порт.

### `auth-svc/pyproject.toml`

> Используем PEP 621 + setuptools. Зависимости ставятся командой `pip install .` из Dockerfile.

```toml
[build-system]
requires = ["setuptools>=68", "wheel"]
build-backend = "setuptools.build_meta"

[project]
name = "auth_svc"
version = "0.1.0"
description = "Auth microservice (FastAPI)"
requires-python = ">=3.12"
dependencies = [
  "fastapi>=0.115",
  "uvicorn[standard]>=0.30",
  "prometheus-fastapi-instrumentator>=7.0"
]

[tool.setuptools]
packages = ["app"]
```

### `auth-svc/Dockerfile`

```dockerfile
FROM python:3.12-slim
ENV PYTHONDONTWRITEBYTECODE=1 \
    PYTHONUNBUFFERED=1
WORKDIR /app
COPY pyproject.toml /app/
COPY app /app/app
RUN pip install --upgrade pip && pip install .
CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8001"]
```

### `auth-svc/.env.example`

```dotenv
# Пример: здесь могли бы быть секреты/строки подключения
# AUTH_JWT_SECRET=change_me
```

### `auth-svc/app/main.py`

```python
from fastapi import FastAPI
from prometheus_fastapi_instrumentator import Instrumentator

app = FastAPI(title="Auth Service")

@app.get("/healthz")
def healthz() -> dict[str, str]:
    return {"status": "ok"}

# /metrics для Prometheus
Instrumentator().instrument(app).expose(app)
```

> **task-svc** и **notify-svc**: те же файлы, но порты 8002 и 8003, и другие названия.

### `task-svc/pyproject.toml`

```toml
[build-system]
requires = ["setuptools>=68", "wheel"]
build-backend = "setuptools.build_meta"

[project]
name = "task_svc"
version = "0.1.0"
description = "Task microservice (FastAPI)"
requires-python = ">=3.12"
dependencies = [
  "fastapi>=0.115",
  "uvicorn[standard]>=0.30",
  "prometheus-fastapi-instrumentator>=7.0"
]

[tool.setuptools]
packages = ["app"]
```

### `task-svc/Dockerfile`

```dockerfile
FROM python:3.12-slim
ENV PYTHONDONTWRITEBYTECODE=1 \
    PYTHONUNBUFFERED=1
WORKDIR /app
COPY pyproject.toml /app/
COPY app /app/app
RUN pip install --upgrade pip && pip install .
CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8002"]
```

### `task-svc/.env.example`

```dotenv
# пример переменных окружения для task-svc
```

### `task-svc/app/main.py`

```python
from fastapi import FastAPI
from prometheus_fastapi_instrumentator import Instrumentator

app = FastAPI(title="Task Service")

@app.get("/healthz")
def healthz() -> dict[str, str]:
    return {"status": "ok"}

Instrumentator().instrument(app).expose(app)
```

### `notify-svc/pyproject.toml`

```toml
[build-system]
requires = ["setuptools>=68", "wheel"]
build-backend = "setuptools.build_meta"

[project]
name = "notify_svc"
version = "0.1.0"
description = "Notify microservice (FastAPI)"
requires-python = ">=3.12"
dependencies = [
  "fastapi>=0.115",
  "uvicorn[standard]>=0.30",
  "prometheus-fastapi-instrumentator>=7.0"
]

[tool.setuptools]
packages = ["app"]
```

### `notify-svc/Dockerfile`

```dockerfile
FROM python:3.12-slim
ENV PYTHONDONTWRITEBYTECODE=1 \
    PYTHONUNBUFFERED=1
WORKDIR /app
COPY pyproject.toml /app/
COPY app /app/app
RUN pip install --upgrade pip && pip install .
CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8003"]
```

### `notify-svc/.env.example`

```dotenv
# пример переменных окружения для notify-svc
```

### `notify-svc/app/main.py`

```python
from fastapi import FastAPI
from prometheus_fastapi_instrumentator import Instrumentator

app = FastAPI(title="Notify Service")

@app.get("/healthz")
def healthz() -> dict[str, str]:
    return {"status": "ok"}

Instrumentator().instrument(app).expose(app)
```

---

## 5) Инфраструктура (Compose + мониторинг)

### `infra/docker-compose.yml`

```yaml
version: "3.9"

networks:
  public:
  private:

services:
  gateway:
    build: ../gateway
    container_name: gateway
    ports:
      - "80:80"
    depends_on:
      - auth-svc
      - task-svc
      - notify-svc
    networks: [public, private]

  auth-svc:
    build: ../auth-svc
    container_name: auth-svc
    environment:
      - PYTHONUNBUFFERED=1
    networks: [private]

  task-svc:
    build: ../task-svc
    container_name: task-svc
    environment:
      - PYTHONUNBUFFERED=1
    networks: [private]

  notify-svc:
    build: ../notify-svc
    container_name: notify-svc
    environment:
      - PYTHONUNBUFFERED=1
    networks: [private]

  prometheus:
    image: prom/prometheus:latest
    container_name: prometheus
    volumes:
      - ./prometheus/prometheus.yml:/etc/prometheus/prometheus.yml:ro
    ports:
      - "9090:9090"
    networks: [private]

  grafana:
    image: grafana/grafana:latest
    container_name: grafana
    environment:
      - GF_SECURITY_ADMIN_USER=admin
      - GF_SECURITY_ADMIN_PASSWORD=admin
    volumes:
      - ./grafana/provisioning/datasources:/etc/grafana/provisioning/datasources:ro
    ports:
      - "3000:3000"
    depends_on:
      - prometheus
    networks: [private]
```

### `infra/prometheus/prometheus.yml`

```yaml
global:
  scrape_interval: 10s

scrape_configs:
  - job_name: "auth-svc"
    static_configs:
      - targets: ["auth-svc:8001"]
        labels:
          group: "services"

  - job_name: "task-svc"
    static_configs:
      - targets: ["task-svc:8002"]
        labels:
          group: "services"

  - job_name: "notify-svc"
    static_configs:
      - targets: ["notify-svc:8003"]
        labels:
          group: "services"
```

### `infra/grafana/provisioning/datasources/datasource.yml`

```yaml
apiVersion: 1

datasources:
  - name: Prometheus
    type: prometheus
    access: proxy
    url: http://prometheus:9090
    isDefault: true
```

---

## 6) Как запустить

```bash
# из корня репозитория
make up          # собрать и поднять всё
make logs        # смотреть логи

# Проверки
curl http://localhost/healthz            # ответ gateway: ok
curl http://localhost/auth/healthz       # через gateway → auth-svc
curl http://localhost/tasks/healthz      # через gateway → task-svc
curl http://localhost/notify/healthz     # через gateway → notify-svc

# Метрики Prometheus каждого сервиса
curl http://localhost/auth/metrics
curl http://localhost/tasks/metrics
curl http://localhost/notify/metrics

# Веб-интерфейсы
# Prometheus:  http://localhost:9090
# Grafana:     http://localhost:3000 (логин/пароль: admin / admin)
```

---

## 7) Пояснения «как чайнику»

* **Микросервис** — маленькое приложение, решающее одну задачу (авторизация, задачи, уведомления). Их проще обновлять и масштабировать отдельно.
* **Gateway (Nginx)** — «входная дверь»: принимает все запросы и пересылает в нужный сервис.
* **/healthz** — простой эндпоинт «я жив», чтобы оркестратор/мониторинг понимал, что сервис работает.
* **/metrics** — цифры по работе сервиса (время ответов, коды ошибок) в формате для Prometheus.
* **Docker** — упаковывает сервис вместе с зависимостями в контейнер, чтобы везде запускался одинаково.
* **Docker Compose** — сценарий, который поднимает сразу все контейнеры одной командой.
* **Prometheus** — собирает метрики с сервисов (ходит на их `/metrics`).
* **Grafana** — рисует красивые графики из метрик Prometheus.
* **Сети public/private** — снаружи виден только gateway и UI мониторинга; сами сервисы общаются в приватной сети.

---

## 8) Дальшие шаги (по желанию)

1. Добавить Postgres/Redis как отдельные сервисы в `infra/docker-compose.yml`.
2. Включить CORS, middleware логирования запросов в `app/main.py`.
3. Повесить дашборды Grafana (импорт готовых JSON‑дашбордов для FastAPI/Prometheus).
4. Настроить алерты (Alertmanager) на p95 latency, error rate.
5. Подключить OpenAPI‑прокси: `/auth/openapi.json` и т.п. через Nginx (удобно для документации).

---

**Готово.** Если нужно — добавим аутентификацию, БД и реальные эндпоинты по твоему ТЗ.
